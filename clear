os.loadAPI("lib/all")

local args = { ... }

local w
local d
local h

if #args < 3 then
    log.error("Expected [width] [depth] [height] arguments")
    return
else
    w = tonumber(args[1]) - 1
    d = tonumber(args[2]) - 1
    h = tonumber(args[3]) - 1
end

m.init(0, 0, -1, 2) -- forward is Z+, right is X-
m.gotoZ(0, true)

local function column()
    print("Doing a column")
    if h == 0 then
        return
    elseif h == 1 then
        turtle.digUp()
    else
        print("h >= 3")
        print("y: " .. m.getY())
        -- If we are starting at the bottom, dig up 1 level
        if m.getY() == 0 then
            print("Going up 1")
            m.gotoY(1, true)
        end

        -- If we are at y=1, dig to the top
        if m.getY() == 1 then
            print("Dig to top")
            turtle.digDown()
            m.gotoY(h-1, true)
            turtle.digUp()
        else
        -- If we are at the top, dig to y=1
            print("Dig to bottom")
            turtle.digUp()
            m.gotoY(1, true)
            turtle.digDown()
        end
    end
end

local function row()
    print("Doing a row")
    --column(h)
    local targetZ = d
    if m.getZ() ~= 0 then
        targetZ = 0
    end

    print(m.getZ(), targetZ, misc.fromTo(m.getZ(), targetZ))
    for z = m.getZ(), targetZ, misc.fromTo(m.getZ(), targetZ) do
        column(h)
        local nextZ = z + misc.sign(z, targetZ)
        m.gotoZ(nextZ, true)
    end
end

for x = m.getX(), -w, -1 do
    print("X: " .. x)
    row()

    -- If we've reached the end of the last row, don't turn
    if x == -w then
        break
    end

    -- Alternate turning left/right at the end
    -- of the row to do a snake-like pattern
    if m.getH() == 2 then
        m.right()
        m.forward(true)
        m.right()
    else
        m.left()
        m.forward(true)
        m.left()
    end
end

m.gotoYXZ(0, 0, -1)
m.turnTo(2)